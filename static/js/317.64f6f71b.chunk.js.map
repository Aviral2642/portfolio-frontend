{"version":3,"file":"static/js/317.64f6f71b.chunk.js","mappings":"2LAKA,MAgIA,EAhIkBA,KAChB,MAAMC,GAAUC,EAAAA,EAAAA,UACVC,GAAWD,EAAAA,EAAAA,UAmEjB,OAXAE,EAAAA,EAAAA,GAAUC,IACJJ,EAAQK,UACVL,EAAQK,QAAQC,SAASC,SAASC,KAAKC,MAAQL,EAAMM,MAAMC,kBAEzDT,EAASG,UACXH,EAASG,QAAQO,SAASC,EAAmD,GAA/CC,KAAKC,IAAmC,GAA/BX,EAAMM,MAAMC,kBACnDT,EAASG,QAAQO,SAASI,GAAK,IAC/Bd,EAASG,QAAQO,SAASK,EAAmD,IAA/CH,KAAKI,IAAmC,GAA/Bd,EAAMM,MAAMC,sBAKrDQ,EAAAA,EAAAA,MAAA,SAAOC,IAAKlB,EAASmB,SAAA,EACnBF,EAAAA,EAAAA,MAAA,QAAMC,IAAKpB,EAAQqB,SAAA,EACjBC,EAAAA,EAAAA,KAAA,eAAaC,KAAM,CAAC,EAAG,EAAG,MAC1BD,EAAAA,EAAAA,KAAA,kBACEE,aArEU,4QAsEVC,eAzDY,mzCA0DZlB,SAAU,CACRC,KAAM,CAAEC,MAAO,GACfiB,OAAQ,CAAEjB,MAAO,IAAIkB,EAAAA,IAAY,UACjCC,OAAQ,CAAEnB,MAAO,IAAIkB,EAAAA,IAAY,UACjCE,OAAQ,CAAEpB,MAAO,IAAIkB,EAAAA,IAAY,YAEnCG,aAAW,EACXC,KAAMJ,EAAAA,UAKVR,EAAAA,EAAAA,MAAA,QAAAE,SAAA,EACEC,EAAAA,EAAAA,KAAA,eAAaC,KAAM,CAAC,IAAK,IAAK,QAC9BD,EAAAA,EAAAA,KAAA,qBACEU,MAAM,UACNF,aAAW,EACXG,QAAS,GACTC,WAAS,QAKbf,EAAAA,EAAAA,MAAA,QAAAE,SAAA,EACEC,EAAAA,EAAAA,KAAA,eAAaC,KAAM,CAAC,IAAK,IAAK,QAC9BD,EAAAA,EAAAA,KAAA,qBACEU,MAAM,UACNF,aAAW,EACXG,QAAS,GACTC,WAAS,OAKZC,MAAMC,KAAK,CAAEC,OAAQ,IAAKC,IAAI,CAACC,EAAGC,KACjCrB,EAAAA,EAAAA,MAAA,QAAcsB,SAAU,CACM,EAA5B3B,KAAKI,IAAIsB,EAAI1B,KAAK4B,GAAK,GACK,EAA5B5B,KAAKC,IAAIyB,EAAI1B,KAAK4B,GAAK,GACK,EAA5B5B,KAAKC,IAAIyB,EAAI1B,KAAK4B,GAAK,IACvBrB,SAAA,EACAC,EAAAA,EAAAA,KAAA,kBAAgBC,KAAM,CAAC,GAAK,EAAG,MAC/BD,EAAAA,EAAAA,KAAA,qBACEU,MAAOQ,EAAI,IAAM,EAAI,UAAY,UACjCV,aAAW,EACXG,QAAS,OATFO,O","sources":["components/CyberCube.js"],"sourcesContent":["import React, { useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\n// import { useTexture } from '@react-three/drei';\nimport * as THREE from 'three';\n\nconst CyberCube = () => {\n  const meshRef = useRef();\n  const groupRef = useRef();\n  \n  // Create a custom shader material for the cyber cube\n  const vertexShader = `\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    \n    void main() {\n      vUv = uv;\n      vPosition = position;\n      vNormal = normal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `;\n  \n  const fragmentShader = `\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 color3;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    \n    void main() {\n      // Create animated gradient based on UV coordinates and time\n      float gradient = sin(vUv.x * 3.14159 + time) * 0.5 + 0.5;\n      gradient += sin(vUv.y * 3.14159 + time * 0.7) * 0.3 + 0.3;\n      gradient = gradient * 0.5;\n      \n      // Mix between three colors\n      vec3 color;\n      if (gradient < 0.33) {\n        color = mix(color1, color2, gradient * 3.0);\n      } else if (gradient < 0.66) {\n        color = mix(color2, color3, (gradient - 0.33) * 3.0);\n      } else {\n        color = mix(color3, color1, (gradient - 0.66) * 3.0);\n      }\n      \n      // Add wireframe effect\n      float wireframe = 1.0 - smoothstep(0.0, 0.02, min(min(vUv.x, vUv.y), min(1.0 - vUv.x, 1.0 - vUv.y)));\n      \n      // Add glow effect\n      float glow = sin(vPosition.x * 10.0 + time) * sin(vPosition.y * 10.0 + time) * sin(vPosition.z * 10.0 + time);\n      glow = glow * 0.1 + 0.9;\n      \n      // Final color with wireframe and glow\n      vec3 finalColor = color * glow;\n      finalColor = mix(finalColor, vec3(1.0), wireframe * 0.3);\n      \n      gl_FragColor = vec4(finalColor, 0.8);\n    }\n  `;\n\n  useFrame((state) => {\n    if (meshRef.current) {\n      meshRef.current.material.uniforms.time.value = state.clock.getElapsedTime();\n    }\n    if (groupRef.current) {\n      groupRef.current.rotation.x = Math.sin(state.clock.getElapsedTime() * 0.5) * 0.1;\n      groupRef.current.rotation.y += 0.01;\n      groupRef.current.rotation.z = Math.cos(state.clock.getElapsedTime() * 0.3) * 0.05;\n    }\n  });\n\n  return (\n    <group ref={groupRef}>\n      <mesh ref={meshRef}>\n        <boxGeometry args={[2, 2, 2]} />\n        <shaderMaterial\n          vertexShader={vertexShader}\n          fragmentShader={fragmentShader}\n          uniforms={{\n            time: { value: 0 },\n            color1: { value: new THREE.Color(0x667eea) }, // Blue\n            color2: { value: new THREE.Color(0x764ba2) }, // Purple\n            color3: { value: new THREE.Color(0xf093fb) }  // Pink\n          }}\n          transparent\n          side={THREE.DoubleSide}\n        />\n      </mesh>\n      \n      {/* Inner rotating cube */}\n      <mesh>\n        <boxGeometry args={[1.2, 1.2, 1.2]} />\n        <meshBasicMaterial\n          color=\"#ff6b6b\"\n          transparent\n          opacity={0.3}\n          wireframe\n        />\n      </mesh>\n      \n      {/* Outer wireframe */}\n      <mesh>\n        <boxGeometry args={[2.5, 2.5, 2.5]} />\n        <meshBasicMaterial\n          color=\"#667eea\"\n          transparent\n          opacity={0.1}\n          wireframe\n        />\n      </mesh>\n      \n      {/* Floating particles around the cube */}\n      {Array.from({ length: 8 }).map((_, i) => (\n        <mesh key={i} position={[\n          Math.cos(i * Math.PI / 4) * 4,\n          Math.sin(i * Math.PI / 4) * 4,\n          Math.sin(i * Math.PI / 2) * 2\n        ]}>\n          <sphereGeometry args={[0.1, 8, 8]} />\n          <meshBasicMaterial\n            color={i % 2 === 0 ? \"#667eea\" : \"#f093fb\"}\n            transparent\n            opacity={0.6}\n          />\n        </mesh>\n      ))}\n    </group>\n  );\n};\n\nexport default CyberCube;\n"],"names":["CyberCube","meshRef","useRef","groupRef","useFrame","state","current","material","uniforms","time","value","clock","getElapsedTime","rotation","x","Math","sin","y","z","cos","_jsxs","ref","children","_jsx","args","vertexShader","fragmentShader","color1","THREE","color2","color3","transparent","side","color","opacity","wireframe","Array","from","length","map","_","i","position","PI"],"sourceRoot":""}