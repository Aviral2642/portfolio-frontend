"use strict";(self.webpackChunkportfolio_client=self.webpackChunkportfolio_client||[]).push([[317],{317:(e,n,o)=>{o.r(n),o.d(n,{default:()=>l});var r=o(5043),i=o(6540),a=o(9435),t=o(579);const l=()=>{const e=(0,r.useRef)(),n=(0,r.useRef)();return(0,i.F)(o=>{e.current&&(e.current.material.uniforms.time.value=o.clock.getElapsedTime()),n.current&&(n.current.rotation.x=.1*Math.sin(.5*o.clock.getElapsedTime()),n.current.rotation.y+=.01,n.current.rotation.z=.05*Math.cos(.3*o.clock.getElapsedTime()))}),(0,t.jsxs)("group",{ref:n,children:[(0,t.jsxs)("mesh",{ref:e,children:[(0,t.jsx)("boxGeometry",{args:[2,2,2]}),(0,t.jsx)("shaderMaterial",{vertexShader:"\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    \n    void main() {\n      vUv = uv;\n      vPosition = position;\n      vNormal = normal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 color3;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    \n    void main() {\n      // Create animated gradient based on UV coordinates and time\n      float gradient = sin(vUv.x * 3.14159 + time) * 0.5 + 0.5;\n      gradient += sin(vUv.y * 3.14159 + time * 0.7) * 0.3 + 0.3;\n      gradient = gradient * 0.5;\n      \n      // Mix between three colors\n      vec3 color;\n      if (gradient < 0.33) {\n        color = mix(color1, color2, gradient * 3.0);\n      } else if (gradient < 0.66) {\n        color = mix(color2, color3, (gradient - 0.33) * 3.0);\n      } else {\n        color = mix(color3, color1, (gradient - 0.66) * 3.0);\n      }\n      \n      // Add wireframe effect\n      float wireframe = 1.0 - smoothstep(0.0, 0.02, min(min(vUv.x, vUv.y), min(1.0 - vUv.x, 1.0 - vUv.y)));\n      \n      // Add glow effect\n      float glow = sin(vPosition.x * 10.0 + time) * sin(vPosition.y * 10.0 + time) * sin(vPosition.z * 10.0 + time);\n      glow = glow * 0.1 + 0.9;\n      \n      // Final color with wireframe and glow\n      vec3 finalColor = color * glow;\n      finalColor = mix(finalColor, vec3(1.0), wireframe * 0.3);\n      \n      gl_FragColor = vec4(finalColor, 0.8);\n    }\n  ",uniforms:{time:{value:0},color1:{value:new a.Q1f(6717162)},color2:{value:new a.Q1f(7752610)},color3:{value:new a.Q1f(15766523)}},transparent:!0,side:a.$EB})]}),(0,t.jsxs)("mesh",{children:[(0,t.jsx)("boxGeometry",{args:[1.2,1.2,1.2]}),(0,t.jsx)("meshBasicMaterial",{color:"#ff6b6b",transparent:!0,opacity:.3,wireframe:!0})]}),(0,t.jsxs)("mesh",{children:[(0,t.jsx)("boxGeometry",{args:[2.5,2.5,2.5]}),(0,t.jsx)("meshBasicMaterial",{color:"#667eea",transparent:!0,opacity:.1,wireframe:!0})]}),Array.from({length:8}).map((e,n)=>(0,t.jsxs)("mesh",{position:[4*Math.cos(n*Math.PI/4),4*Math.sin(n*Math.PI/4),2*Math.sin(n*Math.PI/2)],children:[(0,t.jsx)("sphereGeometry",{args:[.1,8,8]}),(0,t.jsx)("meshBasicMaterial",{color:n%2===0?"#667eea":"#f093fb",transparent:!0,opacity:.6})]},n))]})}}}]);
//# sourceMappingURL=317.64f6f71b.chunk.js.map